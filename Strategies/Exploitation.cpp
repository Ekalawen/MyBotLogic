#include "Exploitation.h"
#include "../BehaviorTree/BT_Noeud.h"
#include <chrono>

BT_Noeud::ETAT_ELEMENT Exploitation::execute() noexcept {
	auto pre = std::chrono::high_resolution_clock::now();

    GameManager::Log("Exploitation");
    // Précondition vérifié : il y a au moins autant d'objectifs que de npcs
    // Calculer si il existe un chemin pour un objectif unique pour chacun des npcs

    // Pour cela on va calculer tous les chemins allant de tous les npcs à tous les objectifs
    // Et on va stocker cet ensemble de chemins, pour chaque npc, dans sa liste de cheminsPossibles
    for (auto& pair : gm.npcs) {
        // On récupère le npc
        Npc& npc = pair.second;
        npc.resetChemins();

        // On récupère tous les chemins à tous ses objectifs
        for (auto objectif : gm.m.objectifs) {
            Chemin chemin = gm.m.aStar(npc.tileId, objectif);
            npc.addChemin(chemin);
        }
    }

    // Ensuite on réinitialise la liste d'objectifsPris du GameManager
    gm.objectifPris = vector<int>{};
	
    // Puis en commancant par le Npc dont la plus courte distance à un objectif est la plus longue
    // On tente de lui affecte cet objectif et de le rajouter cet objectif dans objectifsPris
    // Tant qu'il reste des Npcs qui n'ont pas de chemins
    vector<int> npcAffectes;

	// TEST : on préajoute TOUTES les tuiles déjà affectées au vecteur objectifPris
	for (auto& npc : gm.npcs) {
		if (npc.second.estArrive) {
			npcAffectes.push_back(npc.second.id);
			gm.objectifPris.push_back(npc.second.tileObjectif);
			npc.second.chemin.chemin = {}; // on met le chemin à vide
		}
	}

    while (npcAffectes.size() < gm.npcs.size()) {
        // On récupère le npc qui a le chemin minimal le plus long
        Npc* lastNpc;
        int distMax = -1;
        Chemin cheminMin;
        cheminMin.setInaccessible();
        for (auto& pair_npc : gm.npcs) {
            Npc& npc = pair_npc.second;
            if (find(npcAffectes.begin(), npcAffectes.end(), npc.id) == npcAffectes.end()) { // Si on a pas déjà affecté cet npc !
                Chemin chemin = npc.getCheminMinNonPris(gm.objectifPris, gm.m.tailleCheminMax());
                if (chemin.isAccessible() && chemin.distance() > distMax) {
                    lastNpc = &npc;
                    distMax = chemin.distance();
                    cheminMin = chemin;
                }
            }
        }

		// Puis on lui affecte son chemin le plus court si il y en a un !
		if (!cheminMin.isAccessible()) {

			// Temps d'execution
			auto post = std::chrono::high_resolution_clock::now();
			GameManager::Log("Durée Exploitation = " + to_string(std::chrono::duration_cast<std::chrono::microseconds>(post - pre).count() / 1000.f) + "ms");
			// Si le cheminMin n'a pas été initialisé, c'est qu'il n'y a pas de chemins pour tous les npcs !
			GameManager::Log("Il n'y a pas de chemins pour tous les npcs !");
			return ETAT_ELEMENT::ECHEC;
		}
		lastNpc->chemin = cheminMin;
		if (!cheminMin.empty()) { // Si le chemin est vide, alors on reste sur place !
			lastNpc->tileObjectif = cheminMin.destination();
			gm.objectifPris.push_back(cheminMin.destination());
		}
		else {
			lastNpc->tileObjectif = lastNpc->tileId;
			gm.objectifPris.push_back(lastNpc->tileId);
		}

        npcAffectes.push_back(lastNpc->id);
    }

    // Si on a réussi à affecter un objectif à tous les Npcs, alors on renvoie un succès
    aDejaReussi = true;

    // Temps d'execution
    auto post = std::chrono::high_resolution_clock::now();
    GameManager::Log("Durée Exploitation = " + to_string(std::chrono::duration_cast<std::chrono::microseconds>(post - pre).count() / 1000.f) + "ms");

    return ETAT_ELEMENT::REUSSI;
}
