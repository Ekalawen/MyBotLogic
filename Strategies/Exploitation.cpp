#include "Exploitation.h"
#include "../BehaviorTree/BT_Noeud.h"

#include "MyBotLogic/Tools/Minuteur.h"
#include "MyBotLogic/Tools/Profiler.h"

#include <sstream>
#include <string>
#include <vector>
#include "MyBotLogic/Tools/ThreadPool.h"

#include <mutex>

using std::vector;
using std::stringstream;
using std::endl;

BT_Noeud::ETAT_ELEMENT Exploitation::execute() noexcept {
   Profiler profiler{ GameManager::getLogger(), "Exploitation::execute" };

   // Précondition vérifié : il y a au moins autant d'objectifs que de npcs
   // Calculer si il existe un chemin pour un objectif unique pour chacun des npcs

   // Pour cela on va calculer tous les chemins allant de tous les npcs à tous les objectifs
   // Et on va stocker cet ensemble de chemins, pour chaque npc, dans sa liste de cheminsPossibles

   ThreadPool workers2;
   std::mutex mutex;

   for (auto& pair : manager.getNpcs()) {

      // On récupére le npc
      Npc& npc = pair.second;

      npc.resetChemins();

      // On récupére tous les chemins à tous ses objectifs
      for (auto objectif : manager.c.getObjectifs()) {
         
         std::thread th2{
            [&objectif, &npc, &mutex](Carte& carte) {
            Chemin chemin = carte.aStar(npc.getTileId(), objectif);
            mutex.lock();
            npc.addChemin(chemin);
            mutex.unlock();
            }
            , manager.c
         };
         
         workers2.addThread(std::move(th2));
      }

   }

   workers2.joinAll();

   // Ensuite on réinitialise la liste d'objectifsPris du GameManager
   manager.objectifPris = {};

   // Puis en commancant par le Npc dont la plus courte distance à un objectif est la plus longue
   // On tente de lui affecte cet objectif et de le rajouter cet objectif dans objectifsPris
   // Tant qu'il reste des Npcs qui n'ont pas de chemins
   vector<int> npcAffectes;

   // TEST : on préajoute TOUTES les tuiles déjà affectées au vecteur objectifPris
   for (auto& npc : manager.getNpcs()) {
      if (npc.second.isArrived()) {
         npcAffectes.push_back(npc.second.getId());
         manager.objectifPris.push_back(npc.second.getTileObjectif());
         npc.second.getChemin().resetChemin(); // on met le chemin à vide
      }
   }

   while (npcAffectes.size() < manager.getNpcs().size()) {
      // On récupére le npc qui a le chemin minimal le plus long
      Npc* lastNpc;
      int distMax = -1;
      Chemin cheminMin;
      cheminMin.setInaccessible();
      for (auto& pair_npc : manager.getNpcs()) {
         Npc& npc = pair_npc.second;
         if (find(npcAffectes.begin(), npcAffectes.end(), npc.getId()) == npcAffectes.end()) { // Si on a pas déjà affecté cet npc !
            Chemin chemin = npc.getCheminMinNonPris(manager.objectifPris, manager.c.tailleCheminMax());
            if (chemin.isAccessible() && chemin.distance() > distMax) {
               lastNpc = &npc;
               distMax = chemin.distance();
               cheminMin = chemin;
            }
         }
      }

      // Puis on lui affecte son chemin le plus court si il y en a un !
      if (!cheminMin.isAccessible()) {

         // Temps d'execution
         profiler << "Il n'y a pas de chemins pour tous les npcs !";
         // Si le cheminMin n'a pas été initialisé, c'est qu'il n'y a pas de chemins pour tous les npcs !
         return ETAT_ELEMENT::ECHEC;
      }
      lastNpc->getChemin() = cheminMin;
      if (!cheminMin.empty()) { // Si le chemin est vide, alors on reste sur place !
         lastNpc->setTileObjectif(cheminMin.destination());
         manager.objectifPris.push_back(cheminMin.destination());
      }
      else {
         lastNpc->setTileObjectif(lastNpc->getTileId());
         manager.objectifPris.push_back(lastNpc->getTileId());
      }

      npcAffectes.push_back(lastNpc->getId());
   }
   return ETAT_ELEMENT::REUSSI;
}
