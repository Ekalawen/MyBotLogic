
#include "Exploitation.h"
#include "../BehaviorTree/BT_Noeud.h"
#include "MyBotLogic/Tools/Minuteur.h"

BT_Noeud::ETAT_ELEMENT Exploitation::execute() noexcept {
	auto pre = Minuteur::now();

    GameManager::log("Exploitation");
    // Précondition vérifié : il y a au moins autant d'objectifs que de npcs
    // Calculer si il existe un chemin pour un objectif unique pour chacun des npcs

    // Pour cela on va calculer tous les chemins allant de tous les npcs à tous les objectifs
    // Et on va stocker cet ensemble de chemins, pour chaque npc, dans sa liste de cheminsPossibles
    for (auto& pair : manager.getNpcs()) {
        // On récupère le npc
        Npc& npc = pair.second;
        npc.resetChemins();

        // On récupère tous les chemins à tous ses objectifs
        for (auto objectif : manager.map.getObjectifs()) {
            Chemin chemin = manager.map.aStar(npc.getTileId(), objectif);
            npc.addChemin(chemin);
        }
    }

    // Ensuite on réinitialise la liste d'objectifsPris du GameManager
    manager.objectifPris = {};
	
    // Puis en commancant par le Npc dont la plus courte distance à un objectif est la plus longue
    // On tente de lui affecte cet objectif et de le rajouter cet objectif dans objectifsPris
    // Tant qu'il reste des Npcs qui n'ont pas de chemins
    std::vector<int> npcAffectes;
 
	// TEST : on préajoute TOUTES les tuiles déjà affectées au vecteur objectifPris
	for (auto& npc : manager.getNpcs()) {
		if (npc.second.isArrived()) {
			npcAffectes.push_back(npc.second.getId());
			manager.objectifPris.push_back(npc.second.getTileObjectif());
            npc.second.getChemin().resetChemin(); // on met le chemin à vide
		}
	}

    while (npcAffectes.size() < manager.getNpcs().size()) {
        // On récupère le npc qui a le chemin minimal le plus long
        Npc* lastNpc;
        int distMax = -1;
        Chemin cheminMin;
        cheminMin.setInaccessible();
        for (auto& pair_npc : manager.getNpcs()) {
            Npc& npc = pair_npc.second;
            if (find(npcAffectes.begin(), npcAffectes.end(), npc.getId()) == npcAffectes.end()) { // Si on a pas déjà affecté cet npc !
                Chemin chemin = npc.getCheminMinNonPris(manager.objectifPris, manager.map.tailleCheminMax());
                if (chemin.isAccessible() && chemin.distance() > distMax) {
                    lastNpc = &npc;
                    distMax = chemin.distance();
                    cheminMin = chemin;
                }
            }
        }

		// Puis on lui affecte son chemin le plus court si il y en a un !
		if (!cheminMin.isAccessible()) {

			// Temps d'execution
			auto post = Minuteur::now();
			GameManager::log("Durée Exploitation = " + std::to_string(Minuteur::dureeMicroseconds(pre, post) / 1000.f) + "ms");
			// Si le cheminMin n'a pas été initialisé, c'est qu'il n'y a pas de chemins pour tous les npcs !
			GameManager::log("Il n'y a pas de chemins pour tous les npcs !");
			return ETAT_ELEMENT::ECHEC;
		}
		lastNpc->getChemin() = cheminMin;
		if (!cheminMin.empty()) { // Si le chemin est vide, alors on reste sur place !
            lastNpc->setTileObjectif(cheminMin.destination());
			manager.objectifPris.push_back(cheminMin.destination());
		}
		else {
            lastNpc->setTileObjectif(lastNpc->getTileId());
			manager.objectifPris.push_back(lastNpc->getTileId());
		}

        npcAffectes.push_back(lastNpc->getId());
    }

    // Temps d'execution
    auto post = Minuteur::now();
    GameManager::log("Durée Exploitation = " + std::to_string(Minuteur::dureeMicroseconds(pre, post) / 1000.f) + "ms");

    return ETAT_ELEMENT::REUSSI;
}
