#include "Exploitation.h"
#include "../BehaviorTree/BT_Noeud.h"

#include "MyBotLogic/Tools/Minuteur.h"
#include "../GameManager.h"
#include "MyBotLogic/Tools/Profiler.h"

#include <sstream>
#include <string>
#include <vector>
#include "MyBotLogic/Tools/ThreadPool.h"

#include <mutex>
#include <thread>

using std::vector;
using std::stringstream;
using std::endl;

BT_Noeud::ETAT_ELEMENT Exploitation::execute() noexcept {
   ProfilerRelease* pointeurProfiler = new ProfilerRelease( GameManager::getLoggerRelease(), "Exploitation::toutAStar", true, true );

    // Précondition vérifié : il y a au moins autant d'objectifs que de npcs
    // Calculer si il existe un chemin pour un objectif unique pour chacun des npcs

    // Pour cela on va calculer tous les chemins allant de tous les npcs à tous les objectifs
    // Et on va stocker cet ensemble de chemins, pour chaque npc, dans sa liste de cheminsPossibles
    for (auto& pair : manager.getNpcs()) {
        // On récupére le npc
        Npc& npc = pair.second;
        npc.resetObjectifs();

        // On récupére tous les chemins à tous ses objectifs
        for (int objectif : manager.c.getObjectifs()) {
            // Seulement si notre objectif est accessible
            if (npc.isAccessibleTile(objectif)) {
                //Chemin chemin = manager.c.aStar(npc.getTileId(), objectif, npc.getId(), manager);
                //npc.addChemin(chemin);
                npc.addObjectif(objectif);
                //npc.setTileObjectif(objectif);
            }
        }
    }

    // VERSION AVEC LES THREADS !
  //// ThreadPool workers1;
  // //std::vector<std::mutex> listMutex{ manager.getNpcs().size(), std::mutex{} };

  // for (auto& pair : manager.getNpcs()) {
  // //   std::mutex mutex;

  //    // On récupére le npc
  //    Npc& npc = pair.second;

  //    npc.resetChemins();

  //    // On récupére tous les chemins à tous ses objectifs
  //    for (auto objectif : manager.c.getObjectifs()) {
  //        Chemin chemin = manager.c.aStar(npc.getTileId(), objectif);
  //        npc.addChemin(chemin);
  //       //
  //       //std::thread th1{
  //       //   [&objectif, &npc, &mutex](Carte& carte) {
  //       //   Chemin chemin = carte.aStar(npc.getTileId(), objectif);
  //       //   std::lock_guard<std::mutex> lockGard(mutex); 
  //       //   //mutex.lock();
  //       //   npc.addChemin(chemin);
  //       //   //mutex.unlock();
  //       //   }
  //       //   , manager.c
  //       //};
  //       //
  //       //workers1.addThread(std::move(th1));
  //    }

  // }

  //// workers1.joinAll();

   delete pointeurProfiler;

    // Ensuite on réinitialise la liste d'objectifsPris du GameManager
    manager.objectifPris = {};

	
    // Puis en commancant par le Npc dont la plus courte distance à un objectif est la plus longue
    // On tente de lui affecte cet objectif et de le rajouter cet objectif dans objectifsPris
    // Tant qu'il reste des Npcs qui n'ont pas de chemins
    vector<int> npcAffectes;
 
	//// TEST : on préajoute TOUTES les tuiles déjà affectées au vecteur objectifPris
	//for (auto& npc : manager.getNpcs()) {
	//	if (npc.second.isArrived()) {
	//		npcAffectes.push_back(npc.second.getId());
	//		manager.objectifPris.push_back(npc.second.getTileObjectif());
 //           npc.second.getChemin().resetChemin(); // on met le chemin à vide
	//	}
	//}


    while (npcAffectes.size() < manager.getNpcs().size()) {
        // On récupére le npc qui a le chemin minimal le plus long
        Npc* lastNpc;
        int distMax = -1;
        int objectifMin;

        // Pour chaque npc ...
        for (auto& pair_npc : manager.getNpcs()) {
            Npc& npc = pair_npc.second;

            // Si on a pas déjà affecté cet npc !
            if (find(npcAffectes.begin(), npcAffectes.end(), npc.getId()) == npcAffectes.end()) {

                int objectif = npc.getObjectifMinNonPris(manager.objectifPris, manager.c.tailleCheminMax());
                if (npc.isAccessibleTile(objectif) && npc.distanceToTile(objectif) > distMax) {
                    lastNpc = &npc;
                    distMax = npc.distanceToTile(objectif);
                    objectifMin = objectif;
                }
            }
        }

        // Puis on lui affecte son chemin le plus court si il y en a un !
        if (!lastNpc->isAccessibleTile(objectifMin)) {
            // Temps d'execution
            *pointeurProfiler << "Il n'y a pas de chemins pour tous les npcs !";
            // Si le cheminMin n'a pas été initialisé, c'est qu'il n'y a pas de chemins pour tous les npcs !
            return ETAT_ELEMENT::ECHEC;
        }

        //lastNpc->getChemin() = cheminMin;
        lastNpc->setTileObjectif(objectifMin);
        manager.objectifPris.push_back(objectifMin);

        //if (!cheminMin.empty()) { // Si le chemin est vide, alors on reste sur place !
        //    lastNpc->setTileObjectif(cheminMin.destination());
        //    manager.objectifPris.push_back(cheminMin.destination());
        //} else {
        //    lastNpc->setTileObjectif(lastNpc->getTileId());
        //    manager.objectifPris.push_back(lastNpc->getTileId());
        //}

        npcAffectes.push_back(lastNpc->getId());
    }
    return ETAT_ELEMENT::REUSSI;
}
